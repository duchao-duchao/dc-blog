---
title: react状态管理
date: 2024-10-18T17:02:04Z
slug: post-17
author: duchao-duchao：https://github.com/duchao-duchao
tags: []
---

**标题**: 深度对比 React 状态管理库：如何在技术选型时选择合适的状态库

在前端开发中，React 作为一种广泛流行的框架，不仅简化了组件化开发的流程，同时其内部状态管理也让开发者能够快速上手。然而，随着项目规模的增大和复杂性的增加，单靠 React 自带的 `useState` 和 `useReducer` 往往不足以满足需求，这时候就需要选择一个合适的状态管理库。

本文将对几种主流的 React 状态管理库进行详细对比，包括 **Redux**、**MobX**、**Recoil**、**Zustand** 和 **Jotai**，并且探讨如何在不同的场景下做出正确的技术选型。

---

### 一、为什么需要状态管理库？

React 的核心是组件状态的管理。对于简单的小项目来说，React 自身提供的 `useState`、`useReducer` 就足够了，但是当遇到以下场景时，选择状态管理库显得至关重要：

- **全局状态共享**：多个组件之间共享状态，且不属于任何一个组件本身。
- **复杂的业务逻辑**：涉及到多个步骤和依赖的数据流，导致状态管理变得复杂。
- **持久化状态**：希望在刷新页面时，状态仍然保留（比如本地存储）。
- **跨组件通信**：深层次的组件通信需要避免"prop drilling"（逐层传递 props）。

这些情况下，使用外部状态管理库能够帮助我们提高开发效率、增强代码的可维护性。

---

### 二、主流状态管理库对比

#### 1. Redux

**介绍**: Redux 是 React 生态中最流行的状态管理库之一，提供了一个单一的全局状态树，结合严格的动作（actions）和纯函数（reducers）来更新状态。

- **核心概念**: 
  - 单一状态树：所有状态都存储在一个全局对象中。
  - Actions：描述要对状态进行的操作。
  - Reducers：通过纯函数确定状态的变化。
  - Store：状态的存储库。

- **优点**:
  - **可预测性强**：通过严格的规则管理状态的变化，保证了应用行为的可预测性。
  - **良好的社区支持**：丰富的生态系统，包括中间件（如 `redux-thunk`、`redux-saga`）和开发工具（如 Redux DevTools）。
  - **调试方便**：所有的状态变化都是显式的，可以追踪到具体的 actions。

- **缺点**:
  - **样板代码多**：需要编写大量的样板代码（actions、reducers、dispatchers 等）。
  - **学习曲线较陡**：对于初学者来说，需要掌握较多概念才能熟练使用。

- **适用场景**:
  - 适合大型应用，特别是当你需要非常细致的控制数据流时。
  - 如果团队有多人协作，Redux 通过其明确的结构可以提高协作开发的效率。

#### 2. MobX

**介绍**: MobX 通过响应式编程的方式来处理状态管理，它的状态和视图是自动同步的，能以最小的开发工作量实现高效的状态管理。

- **核心概念**:
  - **Observable state**：状态是响应式的，当状态改变时，自动通知订阅它的组件。
  - **Actions**：修改状态的行为。
  - **Derivations**：通过派生来生成新的状态。
  - **Reactions**：自动观察状态并响应其变化。

- **优点**:
  - **学习曲线低**：相对于 Redux，MobX 的概念较少，易于上手。
  - **开发效率高**：通过自动化的依赖追踪机制，减少手动代码编写量。
  - **性能好**：在大型应用中，由于 MobX 的响应式特性，它可以优化视图的更新频率。

- **缺点**:
  - **不可预测性**：由于状态的自动变化，可能会导致调试困难。
  - **透明度低**：状态的变化不是显式的，开发者很难跟踪每一个状态变更的来源。

- **适用场景**:
  - 适合中小型应用或是状态结构相对简单的项目。
  - 如果你追求快速的开发和维护效率，MobX 是一个不错的选择。

#### 3. Recoil

**介绍**: Recoil 是由 Facebook 开发的状态管理库，旨在解决 React 生态中全局状态管理的难题。它提供了更细粒度的状态控制，并支持并发模式。

- **核心概念**:
  - **Atoms**：最小的状态单元，可以被多个组件共享。
  - **Selectors**：从 atom 中派生出新的状态值，或进行状态的计算。
  - **Concurrent mode**：对 React 并发模式的支持。

- **优点**:
  - **更符合 React 思维**：Recoil 的 API 和 React Hooks 类似，使用起来更加自然。
  - **细粒度更新**：状态的更新是基于 Atom，更新时只会影响与该 Atom 相关的组件，性能更好。
  - **并发支持**：Recoil 原生支持 React 的并发模式，适合未来的 React 应用。

- **缺点**:
  - **成熟度不足**：虽然由 Facebook 维护，但 Recoil 仍然处于活跃开发中，相较于 Redux、MobX 成熟度稍低。
  - **生态支持较少**：与 Redux 等相比，Recoil 的中间件和社区工具较少。

- **适用场景**:
  - 适合追求极简代码和性能优化的 React 项目。
  - 适合想要尝试 React 新特性（如并发模式）的开发者。

#### 4. Zustand

**介绍**: Zustand 是一个极简的状态管理库，使用简单的 API 和 Hooks 来管理全局状态。它主打轻量、易用，同时也支持时间旅行调试。

- **核心概念**:
  - **Store**：通过 `create` 函数创建一个状态存储对象。
  - **Selectors**：状态可以通过 Selector 来派生。
  - **Middleware**：通过扩展和定制化 store 的行为。

- **优点**:
  - **简单、轻量**：API 简单，无需过多配置即可上手。
  - **灵活性高**：Zustand 提供了非常灵活的状态管理方式。
  - **性能好**：由于它的极简设计，Zustand 对性能的影响几乎可以忽略不计。

- **缺点**:
  - **社区支持较少**：相比于 Redux 等，Zustand 的用户基数较小，周边生态不够丰富。

- **适用场景**:
  - 适合小型项目或状态管理需求相对简单的场景。
  - 如果你不需要复杂的中间件支持，Zustand 是一个不错的选择。

#### 5. Jotai

**介绍**: Jotai 是一个基于原子状态的 React 状态管理库，它提供了比 Recoil 更加简洁的 API，同时保持了非常强的灵活性。

- **核心概念**:
  - **Atoms**：最小的状态单元，类似于 Recoil 的原子。
  - **Derivations**：可以在 Atom 基础上派生出新状态。
  
- **优点**:
  - **极简设计**：非常轻量，API 易于理解。
  - **React Hook 风格**：完全符合 React 的 Hooks 设计理念。
  - **零依赖**：没有多余的依赖，适合极简项目。

- **缺点**:
  - **功能较单一**：如果需要复杂的功能（如持久化、复杂的异步逻辑等），需要自定义实现。

- **适用场景**:
  - 适合对包体积有严格要求的项目，或是需要在性能和简洁性之间找到平衡的项目。

---

---

### 三、主流状态管理库使用方式

#### 1. Redux

**使用方式**:  
```javascript
// 安装 Redux 及其工具
npm install redux react-redux

// store.js - 创建 Redux store
import { createStore } from 'redux';

// 定义初始状态
const initialState = { count: 0 };

// 定义 reducer
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 创建 store
const store = createStore(counterReducer);

export default store;

// App.js - 使用 Redux 的组件
import React from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';

function Counter() {
  const count = useSelector((state) => state.count);
  const dispatch = useDispatch();

  return (
    <div>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <span>{count}</span>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
    </div>
  );
}

function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}

export default App;
```

---

#### 2. MobX

**使用方式**:  
```javascript
// 安装 MobX 和 React MobX 依赖
npm install mobx mobx-react-lite

// store.js - 创建 MobX store
import { makeAutoObservable } from 'mobx';

class CounterStore {
  count = 0;

  constructor() {
    makeAutoObservable(this);  // 自动追踪依赖
  }

  increment() {
    this.count++;
  }

  decrement() {
    this.count--;
  }
}

const store = new CounterStore();
export default store;

// App.js - 使用 MobX 的组件
import React from 'react';
import { observer } from 'mobx-react-lite';
import store from './store';

const Counter = observer(() => (
  <div>
    <button onClick={() => store.decrement()}>-</button>
    <span>{store.count}</span>
    <button onClick={() => store.increment()}>+</button>
  </div>
));

function App() {
  return <Counter />;
}

export default App;
```

---

#### 3. Recoil

**使用方式**:  
```javascript
// 安装 Recoil
npm install recoil

// atoms.js - 定义 Recoil 的 atom
import { atom } from 'recoil';

export const countState = atom({
  key: 'countState',  // 每个 atom 需要唯一的 key
  default: 0,  // 初始状态
});

// App.js - 使用 Recoil 的组件
import React from 'react';
import { RecoilRoot, useRecoilState } from 'recoil';
import { countState } from './atoms';

function Counter() {
  const [count, setCount] = useRecoilState(countState);

  return (
    <div>
      <button onClick={() => setCount(count - 1)}>-</button>
      <span>{count}</span>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}

export default App;
```

---

#### 4. Zustand

**使用方式**:  
```javascript
// 安装 Zustand
npm install zustand

// store.js - 创建 Zustand store
import create from 'zustand';

// 使用 Zustand 创建 store
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

export default useStore;

// App.js - 使用 Zustand 的组件
import React from 'react';
import useStore from './store';

function Counter() {
  const { count, increment, decrement } = useStore();

  return (
    <div>
      <button onClick={decrement}>-</button>
      <span>{count}</span>
      <button onClick={increment}>+</button>
    </div>
  );
}

function App() {
  return <Counter />;
}

export default App;
```

---

#### 5. Jotai

**使用方式**:  
```javascript
// 安装 Jotai
npm install jotai

// atoms.js - 定义 Jotai 的 atom
import { atom } from 'jotai';

export const countAtom = atom(0);

// App.js - 使用 Jotai 的组件
import React from 'react';
import { useAtom } from 'jotai';
import { countAtom } from './atoms';

function Counter() {
  const [count, setCount] = useAtom(countAtom);

  return (
    <div>
      <button onClick={() => setCount(count - 1)}>-</button>
      <span>{count}</span>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}

function App() {
  return <Counter />;
}

export default App;
```

---

### 三、如何选择状态管理库？

在项目的技术选型过程中，选择合适的状态管理库可以提高开发效率并增强代码的可维护性。通过上述对比和示例代码，可以根据以下几个因素做出决策：

- **项目规模**：如果项目较小，推荐 Zustand 或 Jotai；如果项目复杂或团队较大，推荐使用 Redux 或 Recoil。
- **团队经验**：团队对 Redux 比较熟悉时，使用 Redux 会更有利于协作；对响应式编程了解的团队可以选择 MobX。
- **性能需求**：当需要细粒度的性能优化时，Recoil 和 Zustand 更具优势。

通过深思熟虑的技术选型，可以确保项目的状态管理既高效又易于维护。

---
此文自动发布于：<a href="https://github.com/duchao-duchao/dc-blog/issues/17" target="_blank">github issues</a>
